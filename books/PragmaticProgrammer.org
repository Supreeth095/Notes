* Preface
** What makes a Pragmatic Programmer
- Early adopter/fast adapter
- Inquisitive
- Critical thinker
- Realistic: realism gives you a good feel for how difficult things are, and how long things will take. Understanding for yourself that a process should be difficult or will take a while to complete gives you the stamina to keep at it.
- Jack of all trades

Most basic characteristics:
- care about your craft
- Think! About your work

** It's a Continuous Process
Management consultants like to drop the word /kaizen/ in conversations. "Kaizen" is a Japanese term that captures the concept of continously making may small improvements. It was considered one of the main reasons for the dramatic gains in productivity and quality in Japanese manufacturing and was widely copied throughout the world.
Kaizen applies to individuals too. Everyday work to refine your skills you have and to add new tools to your repetoire. 

* A Pragmatic Philosophy
- What distinguishes Pragmatic Programmers
  + an attitude
  + a style
  + a philosophy
  + take responsibility for everything they do
- Learning is a continuous and ongoing process
- Pragmatic programming stems from a philosophy of pragmatic thinking

** The Cat Ate My Source Code
/The greatest of all weaknesses is the fear of appearing weak
One of the cornerstones of the pragmatic philosophy is the idea of taking responsibility for yourself and your actions in terms of your career advancement, your project, and your day-to-day work. A pragmatic programmer isn't admit ignorance or error.
- *Take Responsibility*:
  + when do you accept the repsonsibility for an outcome, you should expect to be held accountable for it. When you make a mistake or an error in judgement, admit it honestly and try to offer options.
  + don't blame someone or something else, or make up an excuse.

*Provide Options, Don't Make Lame Excuses*

- Instead of excuses, provide options. Explain what can be done to salvage the situation
  + does code have to be thrown out
  + educate them on the value of refactoring
  + spend time prototyping to determine the best way to proceed
  + do you need to introduce better testing.

*** Related sections:
  + Prototypes and Post-it Notes
  + Refactoring
  + Code that's Easy to test
  + Ubiquitous Automation
  + Ruthless Testing

*** Challenges

** Software Entropy
- When disorder increases in software, programmers call it "software rot". There are many factors that can contribute to software rot. The most important one is: psychology, or culture, at work on a project.

*Don't Live with Broken Windows*

- Don't leave "broken windows" (bad designs, wrong decisions, poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up!
- neglect accelerates the rot faster than any factor. Don't let entropy win.

- *Putting Out Fires*:

*** Related sections include:
- Stone Soup and Boiled Frogs
- Refactoring
- Pragmatic Teams

*** Challenges
** Stone Soup and Boiled Frogs
- People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources. Sometimes this is called "start-up fatigue".
- Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel. Sit back and wait for them to start asking you to add the functionality you originally wanted. People find it easier to join an ongoing success. Show them a glimpse of the future and you'll get them rally around.

*Be a Catalyst for Change*

*** The villagers' Side
- Most software diasters start out too small to notice, and most project overruns happen a day at a time. 
*Remember the Big Picture*

*** Related sections include:
- Software Entropy
- Programming by Coincidence
- Refactoring
- The requirements Pit
- Pragmatic Teams

*** Challenges
Can you determine whether you're making stone soup or frog soup when you try to catalyze change? Is the decision subjective or objective?

*** Good-Enough Software
Striving to better, oft we mar what's well
*** Involve Your Users in the Trade-Off
- the scope and quality of the system you produce should be specified as part of that system's requirements
*Make Quality a Requirements Issue*
- If you give your users something to play with early, their feedback will often lead you to a better eventual solution.

*** Know When to Stop
- Code could never be perfect. Don't spoil a perfectly good program by overembellishment and over-refinement. Move on, and let your code stand in its own right for a while.

*** Releated sections include
- Tracer Bullets
- The Requirements Pit
- Pragmatic teams
- Great Expectations

*** Challenges
** Your Knowledge Portfolio
An investment in knowledge always pays the best interest
-- Benjamin Fraklin

- Your knowledge and experience are your most important professional assets, but they're expiring assets

*** Your Knowledge Portfolio
- Manage a knowledge portfolio is very similar to managing a financial portfolio:
  + serious investors invest regularly -- as a habit
  + Diversification is the key to long-term success
  + smart investors balance their portfolio between conservative and high-risk, high-reward investments
  + Investors try to buy low and sell high for maximum return
  + Portfolios should be reviewed and rebalanced periodically

*** Building Your Portfolio
- *Invest Regularly*: The habit itself, is as important as the sums
- *Diversify*: The more /different/ things you know, the more valuable you are.
- *Manage Risk*: don't put all your technical eggs in one basket
- *Buy low, sell high*: 
- *Review and Rebalance*:

*Invest Regularly in Your Knowledge Portfolio*




*** Goals
- Learn at least one new language every year
- Read a technical book each quarter
- Read nontechnical books too
- Take classes
- Participate in local user groups: Don't just go and listen, but actively participate
- Experiment with different environments
- Stay current
- Get wired

*** Opportunities for Learning
- find the answer (ask gurus, search web) --> find someone who can answer. time is already in short supply so you need to plan ahead.

*** Critical Thinking
- Think critically about what you read and hear
*Critically Analyze What You Read and Hear*

*** Challenges
- Start learning a new language
- Start reading a new book (finish this one first!). If you're doing very detailed implementation and coding, read a book on design, vice versa
- Get out and talk technology with people who aren't involved in your project

** Communicate!
I believe that it is better to be looked over than it is to be overlooked.
-- Mae West, Belle of the Nineties, 1934
*** Know What you Want to Say
- Plan what you want to say. Write an outline. Refine it until it does

*** Know Your Audience
acrostic wisdom
                    What do you want them to learn?
      What is their interest in what you've got to say?
                How sophisticated are they?
           how much detail do they want
Whom do you want to own the information
        How can you motivate them to listen to you?

*** Choose your Moment
*** Choose a Style
*** Make It Look Good
Your ideas are important and they deserve a good-looking vehicle to convey them to your audience
*** Involve Your Audience
*** Be a Listener
if you want people to listen to you: listen to them

*** Get Back to People
*It's Both What You Say and the Way You Say it*

* A Pragmatic Approach
- certain tips and tricks that apply at all levels of software development that are rarely documented, written down as odd sentences in dicussions of design, project management, or coding
- The Evils of Duplication and Orthogonality
  + not to duplicate knowledge throughout your systems
  + not to split any one piece of knowledge across multiple system components
- Reversibility: 
  + techniques that help insulate your projects from their changing environment
- Tracer Bullets:
  + gather requirements, test designs, and implement code @ the same time
- Prototypes & Post it: how to use prototyping to test architectures, algorithms, interfaces, and ideas
- Estimating
** The Evils of Duplication
- Knowledge isn't stable --> we spend a large part of our time in maintenance mode, reorganizing and reexpressing the knowledge in our systems
- Maintenance is not a discrete activity, but a routine part of the entire development process
- When we perform maintenance, we have to find and change the representations of things, those capsules of knowledge embedded in the application.
- DRY principle:
  Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

*** How Does Duplication Arise?
- categories of the duplication:
  + *Imposed Duplication*: Developers feel they have no choice -- the environment seems to require duplication
  + *Inadvertent duplication*: Developers don't realize that they are duplicating information
  + *Impatient duplication*: Developers get lazy and duplicate because it's easier
  + *Interdeveloper duplication*: Multiple ppl on a team duplicate a piece of information

- *Imposed Duplication*: 
  + Multiple representations of information: write a simple filter or code generator
  + Documentation in code: DRY principle tells us to keep the low-level knowledge in the code and reserve the comments for other, high-level explanations
  + Documentation and code: 
  + Language issues: think about comments in header and implementation files

- *Inadvertent Duplication*:
  + duplication comes about as the result of mistakes in the design

- *Impatient Duplication*:
  + shortcuts make for long delays
  + impatient duplication is an easy form to detect and handle, but it takes discipline and a willingness to spend time up front to save pain later.

- *Interdeveloper Duplication*:
  
- *Make It Easy to Reuse*

*** Related sections:
- Orthogonality
- Text Manipulation
- Code Generators
- Refactoring
- Pragmatic Teams
- Ubiquitous Automation
- It's All Writing

** Orthogonality
- critical concept if you want to produce systems that are easy to design, build, test, and extend
*** What is Orthogonality?
- 2 or more things are orthogonal if changes in one do not affect any of the others
  database code will be orthogonal to the user interface
- A Nonorthogonal System:
  + helicopter controls

*** Benefits of Orthogonality
- *Eliminate Effects Between Unrelated Things*
- 2 major benefits: increased productivity and reduced risk
- *Gain productivity*:
  + Changes are localized, so development time and testing time are reduced
  + An orthogonal approach also promotes reuse. The more loosely coupled your systems, the easier they are to reconfigure and reengineer
  + a fairly subtle gain in productivity when you combine orthogonal components

- *Reduce Risk*: reduces the risks inherent in any development
  + diseased sections of code are isolated
  + the resulting system is less fragile
  + an orthogonal system will probably be better tested
  + not be as tightly tied to a particular vendor, product, or platform

*** Project Teams
- project teams are efficient when they are organized orthoganally
- informal measure of the orthogonality: how many ppl need to be involved in discussing each change
*** Design
- organizing components into layers is an powerful approach

*** Toolkits and Libraries
- choose your technologies wisely because libraries and toolkits you choose can destroy orthogonality
- when you bring in a toolkit, ask yourself whether it imposes changes on your code that shouldn't be there 
- EJB / Aspect-Oriented Programming (AOP) are interesting technologies

*** Coding
- Several techniques you can use to maintain orthogonality:
  + Keep your code decoupled:
    write modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations
  + Avoid global data: 
    ~ code ties itself into the other components that share data when using global data
    ~ The code is easier to understand and maintain if you explicitly pass any required context into your modules (through objects' constructors)
  + Avoid similar functions

*** Testing
- An orthogonally designed and implemented system is easier to test
- Building unit tests is itself an interesting test of orthogonality
- Bug fixing is also a good time to assess the orthogonality of the system

*** Documentation
- Orthogonality also applies to documentation
- modern processors provide style sheets and macros that help

*** Living with Orthogonality
- if a project is not orthogonally designed and coded, it's time to refactor.

*** Related sections include:
- The Evils of Duplication
- Source Code Control
- Design by Contract
- Decoupling and the Law of Demeter
- Metaprogramming
- It's just a View
- Refactoring
- Code that's easy to Test
- Evil Wizards
- Pragmatic Teams
- It's All Writing

    

** Reversibility
Nothing is more dangerous than an idea if it's the only one you have

*** Reversibility
- The mistake lies in assuming that any decision is cast in stone and in not preparing for the contingencies that might arise.
- *There Are No Final Decisions*

*** Flexible Architecture
- Think about maintaining flexibility in the areas of architecture, deployment and vendor integration.
- Technologies such as CORBA can help insulate portions of a project from changes in development language or platform.

*** Related sections include:
- Decoupling and the Law of Demeter
- Metaprogramming
- It's Just a View

** Tracer Bullets
Pragmatic Programmers tend to prefer using tracer bullets
*** Code that Glows in the Dark
- *Use Tracer Bullets to Find the Target*
- Tracer code is not disposable: you write it for keeps. It contains all the error checking, structuring, documentation, and self-checking
- advantages:
  + *Users get to see something working early*
  + *Developers build a structure to work in*
  + *You have an integration platform*
  + *You have something to demonstrate*
  + *You have a better feel for progress*

*** Tracer Bullets Don't Always Hit Their Target
- Tracer bullets show what you're hitting. This may not always be the target. You then adjust your aim until they're on target. That's the point.

*** Tracer Code verus Prototyping
- Prototyping generates disposable code - Tracer code is lean but complete

*** Related sections include
- Good-Enough Software
- Prototypes and Post-it Notes
- The Specification Trap
- Great Expectations

** Prototypes and Post-it Notes
- use prototypes to try out specific ideas; prototyping is much cheaper than full-scale production.
- we can build prototypes out of different materials

*** Things to Prototype
- Anything that carries risk, hasn't been tried before, absolutely critical, unproven, experimental, doubtful.
  + Architecture
  + New functionality in an existing system
  + Structure or contents of external data
  + Third-party tools or components
  + Performance issues
  + User interface design

- The poin of prototyping: prototyping is a learning experience
- *Prototype to Learn*

*** How to Use Prototypes
- What details can you ignore?
  + Correctness
  + Completeness
  + Robustness
  + Style

*** Prototyping Architecture
- specific areas you may want to look for in the architectural prototype:
  + Are the responsibilities of the major components well defined and appropriate?
  + Are the collaborations between major components well defined
  + Is compling minimized?
  + Can you identify potential sources of duplication
  + Are the interface definitions and constraints acceptable?
  + Does every module have an access path to the data it needs during executiong? Does it have that access when it needs it?

*** How Not to Use Prototypes
- make sure that everyone understands that you are writing disposable code
- prototype --> tracer bullets

*** Related sections include:
- The Cate Ate My Source Code
- Communicate
- Tracer Bullets
- Great Expectations

** Domain Languages
The limits of language are the limits of one's world

- *Program Close to the Problem domain*

*** Implementing a Mini-Language
- define a syntax first using a notation (BNF)
- use bison / lex / yacc

*** Data Languages and Imperative Languages
*** Stand-Alone and Embedded Languages

*** Related sections include:
- Metaprogramming

** Estimating
- *Estimate to Avoid Surprises*
*** How Accurate is Accurate Enough
- specify the context in which the answer will be taken? Do they need high accuracy or are they looking for a ballpark figure
- recommend: scale time estimates as follows:
| Duration     | Quote estimate in                    |
|--------------+--------------------------------------|
| 1 - 15 days  | days                                 |
| 3 - 8 weeks  | weeks                                |
| 8 - 30 weeks | months                               |
| 30+ weeks    | think hard before giving an estimate |
|              |                                      |

*** Where do Estimates Come From?
- basic estimate trick: ask someone who's already done it
- Understand What's Being Asked:
  + have a grasp of the scope of the domain

- Build a Model of the System
  + build a rough and ready bare-bones mental model: the model may be the steps that your organization uses during development, along with a very rought picture of how the system might be implemented
  + the process of building the model leads to discoveries of underlying patterns and processes
  + Inaccuracies are inevitable and beneficial

- Break the Model into Components
  + decompose it into components
  + discover the mathematical rules that describe how these components interact
  + identify each parameter that contributes to the overall model

- Give Each Parameter a Value
  + work out which parameters have the most impact on the result

- Calculate the Answers
  + During the calculationg phase, you may start getting answers that seem strange. If the arithmetic is correct, your understand of the problem or your model is probably wrong.

- Keep Track of Your Estimating Prowess
  + record the estimates to see how close we were
  + keep track of all subestimates

*** Estimating Project Schedules
- Repeat the following steps:
  + Check requirements
  + Analyze risk
  + Design, implement, integrate
  + Validate with the users

- *Iterate the Schedule with the Code*
- This may not be popular with management, who typically want a single, hard-and-fast number before the project even starts. Help them understand that the team, their productivity and the environment will determine the schedule.

*** What to Say When Asked for an Estimate
- You say "I'll get back to you"
- you almost always get better results if you slow the process down and spend some time going through the steps we describe

*** Releated sections include:
Algorithm Speed

*** Challenges
- Keep a log of your estimates

* The Basic Tools
** The Power of Plain Text
- the best format for storing knowledge persistently is plain text: we are able to manipulate knowledge, both manually and programmatically, using virtually every tool at our disposal

*** What is Plain Text?
- plain text is made up of printable characters in a form that can be read and understood directly by people
- XML, SGML, HTML are great examples of plain tet that has a well-defined structure
- problem w/ binary formats: context necessary to understand the data is separate from the data itself.
- *Keep Knowledge in Plain Text*

*** Drawbacks
- 2 major drawbacks:
  + take more space to store than a compressed binary format
  + computationally more expensive to interpret and process

*** The Power of Text
- benefits of plain text:
  + Insurance against obsolescence
  + Leverage
  + Easier testing

- Insurance Against Obsolescence
  + parse a text file w/ only partial knowledge of its format

- Leverage
  + every tool in the computing universe (source code management systems, compiler, editors, stand-alone filters) can operate on plain text

- Easier Testing
  + modify test data w/o having to create any special tools

*** Lowest Common Denominator
- Plain text is a standard for communicating among all parties

*** Related sections include
- Source Code Control
- Code Generators
- Metaprogramming
- Blackboards
- Ubiquitous Automation
- It's All Writing
    
** Shell Games
- *Use the Power of Command Shells*
** Power Editing
- *Use a Single Editor Well*
- Choose an editor, know it thoroughly, and use it for all editing tasks.

** Editor Features
- abilities of decent editor (u should use)
  + configurable
  + extensible
  + programmable

** Productivity
- Some editors can help streamline common operations:
  + name of the class or module filled in
  + your name and/or copyright statements
  + skeletons for constructs in that language
- auto-indenting

** Where to Go from here
** Source Code Control
Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it

- *Always Use Source Code Control*

- Make sure that everything is under source code control - documentation, phone number, lists, memos to vendors, makefiles, build and release procedures, little shell script that burns the CD master - everything.

*** Source Code Control and Builds
- benefit in having an entire project under the umbrella of a source code control system you can have a product builds that are:
  + automatic
  + repeatable

** Debugging
It is a painful thing
To look at your own trouble and know
That you yourself and no one else has made it
*** Psychology of Debugging
- Debugging itself is a sensitive, emotional subject for many developers
- *Fix the Problem, Not the Blame*

*** A Debugging Mindset
The easiest person to deceive is one's self
- *Don't panic*
- Don't waste a single neuron on the train of thought that begins "but that can't happen"
- Always try to discover the root cause of a problem, not just this particular appearance of it.

*** Where to Start
- Working on code that compiled cleanly - w/o warnings
- accurate in observations / gather all the relevant data
- 2 points:
  + interview the user who reported the bug in order to gather more data than you were initially given
  + Artificial test don't exercise enough of an application.

*** Debugging Strategies
- reproduce bug
- visualize your data
- tracing
  + watch the state of a program or a data structure overtime
  + tracing statements are effective in systems where time itself is a factor: concurent processes, real-time systems, and event-based applications
- Rubber Ducking: explain the problem to someone else
- Process of Elimination
  + always assume that problem is in your code. Eliminate your code before submitting the bug report

- *"select" Isn't Broken"

*** The Element of Surprise
- *Don't Assume It - Prove It*

*** Releated sections include:
- Assertive Programming
- Programming by Coincidence
- Ubiquitous Automation
- Ruthless Testing

** Text Manipulation
- *Learn a Text Manipulation Language*
- applicability of text manipulation languages:
  + Database schema maintenance*
  + Java property access
  + Test data generation
  + Book writing
  + C to Object Pascal interface
  + Generating Web documentation
*** Related sections include:
- The Evils of Duplication    

** Code Generators
- *Write code that writes code*
- 2 main types of code generators:
  + Passive code generators: are run once to produce a result
  + Active code generators

*** Passive Code Generators
- Passive Code generators save typing
- many uses:
  + Creating new source files
  + Performing one-off conversions
  + Producing lookup tables and other resources

*** Active code Generators
*** Code generators needn't be complex
*** Code Generators Needn't Generate Code
*** Related sections include:
- The Evils of Duplication
- The Power of Plain Text
- Evil Wizards
- Ubiquitous Automation

* Pragmatic Paranoia
- *You can't write perfect software* <- accept it as an axiom of life
- Pragmatic Programmers: don't trust themselves. 
- In a world of imperfect systems, ridiculous time scales, laughable tools, and impossible requirements, let's play it safe.

When everybody actually is out to get you, paranoia is just good thinking

** Design by Contract
- Nothing astonishes men so much as common sense and plain dealing
- One of the best solutions for ensuring plain dealing is the contract

*** DBC (Design By Contract)
- DBC: powerful technique that focuses on documenting the rights and responsibilities of software modules to ensure program correctness. 
- before a software system does something, it may have some expectation of the state of the world, and it may be able to make a statement about the state of the world when it concludes.
  + Preconditions: what must be true in order for the routine to be called; the routine's requirements
  + Postconditions: the state of the world when the routine is done
  + Slass invariants: a class ensures that this condition is always true from the perspective of a caller
- DBC's emphasis is on "lazy" code
- W/o a contract, all the compiler can do is ensure that a subclass conforms a particular method signature

*** Implementing DBC
- The greatest benefit of using DBC may be that it forces the issue of requirements and guarantees to the forefront. 
- Enumerate at design time:
  + the input domain range
  + the boundary conditions
  + what the routines promise to deliver

*** Assertions
- You can get much benefic by having the compiler check your contract for you. You can partially emulate this in some languages by using assertions. Why only partially?  
  + no support for propagating assertions down an inheritance hierarchy.
  + There is no built-in concept of old values:
  + the runtime system and libraries are not designed to support contracts

*** Language Support
*** DBC and Crashing Early
*** Other Uses of Invariants
- A loop invariant is a statement of the eventual goal of a loop, but is generalized so that it is also valid before the loop executes and on each iteration through the loop.
*** Semantic Invariants
- You can use semantic invariants to express inviolate requirements, a kind of "philosophical contract"
- When you find a requirement that qualifies, make sure it become a well-known part of whatever documentation you are producing

*** Dynamic Contracts and Agents
- Contracts as fixed, immutable specifications, but in the landscape of autonomous agents, this doesn't need to be the case.
- Certainly any system that relies on agent technology has a critical dependence on contractual arrangements - even if they are dynamically generated.

*** Related sections include:
- Orthogonality
- Dead Programs Tell No Lies
- Assertive Programming
- How to Balance Resources
- Decoupling and the law of demeter
- Temporal Coupling
- Programming by Coincidence
- Code that's Easy to Test
- Pragmatic Teams

** Dead Programs Tell No Lies
- All errors give you information. Pragmatic Programmers tell themselves that if there is an error, something very, very bad has happened.
- *Crash Early*

*** Crash, Don't Trash
- One of the Benefits of detecting problems as soon as you can is that you can crash earlier.
- The basic principle stays the same - when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible. A dead program normally does a lot less damage than a crippled one.

*** Related sections include:
- Design By Contract
- When to Use Exceptions    


** Assertive Programming
/There is a luxury in self-reproach. When we blame ourselves we feel no one else has a right to blame us/

*** Oscar Wilde, The Picture of Dorian Gray
- It seems that there's a mantra that every programmer must memorize early in his career. It is a core belief that we learn to apply to requirements, designs, code, comments, just about everything we do. 
  
  "This can never happen"

- *If it can't happen, use assertions to ensure that it won't*

- the condition passed to an assertion should not have a side effect
  assertions may be turned off at compile time - never put code that must be executed into an assert

*** Leave Assertions Turned On
- Turning off assertiongs when you deliver a program to production is like crossing a high wire without a net because you once made it accross in practice. There's dramatic value, but it's hard to get life insurance.
- IF you do have performance issues, turn off only those assertions that really hit you.

*** Related sections include
- Debugging
- Design by Contract
- How to Balance Resources
- Programming by Coincidence


** When to Use Exceptions
*** What is Exceptional
- One of the problems with exceptions is knowing when to use them. Exceptions should rarely be used as part of a program's normal flow
- *Use Exceptions for Exceptional Problems*
- An exception represents an immediate, nonlocal transfer of control - It's a kind of cascading goto. Programs that use exceptions as part of their normal processing suffer from all the readability and maintainability problems of classic spaghetti code. These programs break encapsulation: routines and their callers are more tightly coupled via exception handling.

*** Error Handlers are an Alternative
- An error handler is a routine that is called when an error is detected. You can register a routine to handle a specific category of errors. When one of these errors occurs, the handler
- There are times when you may want to use error handlers, either instead of or alongside exceptions. 
- Example: the implementation of a client-server application, using Java's Remote Method Invocation (RMI) facility. Every call to a remote routine must be prepared to handle a RemoteException. Adding code to handle these exceptions can become tedious. A possible work-around is to wrap your remote objects in a class that is not remote. This class then implements an error handler interface.

*** Related sections include:
- Dead Programs Tell No Lies

*** Challenges
** How to Balance Resources
"I brought you into this world", my father would say, "and I can take you out. it don't make no difference to me. I'll just make another one like you".
- *Finish What you Start*

*** Nest Allocations
- The base pattern for resource allocation can be extended for routines that need more than one resource at a time. There are just 2 more suggestions:
  + Deallocate resources in the opposite order to that in which you allocate them. That way you won't orphan resources if one resource contains references to another.
  + When allocating the same set of resources in different places in your code, always allocate them in the same order.

** Objects and Exceptions
- The equilibrium between allocations and deallocations is reminiscent of a class's constructor and destructor.

** Balancing and Exceptions
- Language that support exceptions can make resource deallocation tricky. If an exception is thrown, how do you guarantee that everything allocated prior to the exception is tidied up. The answer depends to some extent on the language

*** Balancing Resources with C++ Exceptions
- wrap resource in an object (smart_ptr)
*** Balancing Resources with Java Exceptions
- use "finally"

** When you can't Balance Resources
- there are times when the basic resource allocation pattern isn't appropriate. Commonly this is found in programs that use dynamic data structures.
- The trick here is to establish a semantic invariant for memory allocation. You need to decide who is responsible for data in an aggregate data structure. What happens when you deallocate the top-level structure? You have 3 main options:
  + The top-level structure is also responsible for freeing any substructures that it contains. These structures then recursively delete data they contai
  + The top-level structure is simply deallocated. Any structures that it pointed to (that are not referenced elsewhere) are orphaned
  + The top-level structure refuses to deallocate itself if it contains any substructures
- You can write your own form of limited automatic garbage collection by implementing a reference counting sheme on your dynamically allocated objects.

** Checking the Balance
- Pragmatic Programmers trust no one, we feel it is always a good idea to build code that actually checks that resources are indeed freed appropriately. For most applications, this normally means producing wrappers for each type of resource, and using these wrappers to keep track of all allocations and deallocations.
- invest in tools that check your running programs for memory leaks

*** Related sections include
- Design by Contract
- Assertive Programming
- Decoupling and the Law of Demeter



* Bend or Break
- We need to make every effort to write code that's as loose - as flexible - as possible
- In this chapter, we'll tell you how to make reversible decisions
- First we need to look at /coupling/ - the dependencies among modules of code. In /Decoupling and the Law of Demeter/, we'll show how to keep separate concepts separate, and decrease coupling
- /Metaprogramming/ will explain how to move details out of the code completely, where they can be changed more safely and easily.
- In /Temporal Coupling/ we'll look at 2 aspects of time as they relate to coupling.
- A key concept in creating flexible code is the separation of a data /model/ from a /view/. We'll decouple models from view in /It's just a View/
- Finally, there's a technique for decoupling modules even further by providing a meeting place where modules can exchange data anonymously and asynchronously. This is the topic of /Blackboards/

** Decoupling and the Law of Demeter
- /Good fences make good neighbors/
- spies, dissidents, revolutionaries and such are often organized into small groups of people called /cells/. Although individuals in each cell may know each other, they have no knowledge of those in other cells.

*** Minimize Coupling
- Traversing relationships between objects directly and quickly lead to a combinatorial explosion of dependency relationships. You can see symptoms of this phenomenon in a number of ways:
  + Large C or C++ projects where the command to link a unit test is longer than the test program itself
  + "Simple" changes to one module that propagate through unrelated modules in the system
  + Developers who are afraid to change code because they aren't sure what might be affected.

*** The Law of Demeter for Functions
- The Law of Demeter for functions attempts to minimize coupling between modules in any given program. It tries to prevent you from reaching into an object to gain access to a third object's methods
- The Law of Demeter for functions states that any method of an object should call only methods belong to itself
- *Minimize Coupling Between Modules*

*** Does it Really Make a Difference?
- classes in C++ with larger response sets are more prone to error than classes with smaller response sets
- cost of the Law of Demeter: as a "general contractor" your module must delegate and manage any and all subcontractors directly, w/o involving clients of your module. In practice, this means that you will be writing a large number of wrapper methods that simply forward the request on to a delegate.
- As with any technique, you must balance the pros and cons for your particular application. In database schema design it is common practice to "denormalize" the schema for a performance improvement; to violate the rules of normalization in exchange for speed
- Read "Large-scale C++ software Design"

*** Related sections include
- Orthogonality
- Reversibility
- Design by Contract
- How to Balance Resources
- It's just a view
- Pragmatic Teams
- Ruthless Testing



** Metaprogramming
- /No amount of genius can overcome a preoccupation with detail/ Levy's Eighth Law

*** Dynamic Configuration
- We want to make our systems highly configurable: deeply ingrained items as the choice of algorithms, database products, middleware technology, and user-interface style. These items should be implemented as configuration options, not through integration or engineering.
- *Configure. Don't Integrate*
- Use /metadata/ to describe configuration options for an application: tuning parameters, user preferences, the installation directory

*** Metadata-Driven Applications
- Our goal is to think declaratively and create highly dynamic and adaptable programs. We do this by adopting a general rule: program for the general case, and put the specifics somewhere else - outside the compiled code base
- *Put Abstractions in Code Details in Metadata*
- There are several benefits to this approach:
  + It forces you to decouple your design, which results in a more flexible and adaptable program
  + It forces you to create a more robust, abstract design by deferring details - deferring them all the way out of the program.
  + You can customize the application w/o recompiling it. You can also use this level of customization to provide easy work-arounds for critical bugs in live production systems
  + Metadata can be expressed in a manner that's much closer to the problem domain than a general-purpose programming language 
  + You may even be able to implement several different projects using the same application engine, but with different metadata.

*** Business Logic
- Becaues business policy and rules are more likely to change than any other aspect of the project, it makes sense to maintain them in a very flexible format.
- Example: EJB

*** Related sections include
- Orthogonality
- Reversibility
- Domain Languages
- The Power of Plain Text

** Temporal Coupling
- What is /temporal coupling/ all about, you may ask. It's about time.
- Time is an often ignored aspect of software architectures. There are 2 aspects of time that are important to us: concurrency (things happening at the same time) and ordering (the relative positions of things in time).
- We don't usually approach programming with either of these aspects in mind. When people first sit down to design an architecture or write a program, things tend to be linear. That's the way most people think - do this and then always do that. But thinking this way leads to /temporal coupling/: coupling in time.

*** Workflow
- capture description of workflow using a notation such as the UML activity diagram
- An activity diagram consists of a set of actions drawn as rounded boxes. The arrow leaving an action leads to either another action or to a thick line called a /synchronization bar/. Once all the actions leading into a synchronization bar are complete, you can then proceed along any arrows leaving the bar. An action with no arrows leading into it can be started at any time.
- You can use activity diagrams to maximize parallelism by identifying activities that could be performed in parallel.

*** Architecture
- Case study: OLTP system - multiprocessing distributed application
- The design addresses the following constraints:
  + Database operations take a relatively long time to complete.
  + For each transaction, we must not block communication services while a database is being processed.
  + Database performance suffers with too many concurrent sessions.
  + Multiple transactions are in progress concurrently on each data line.
- TIP: *Design Using Services*
- OLTP systems: instead of components, we have really created /services/ -- independent, concurrent objects behind well-defined consistent interfaces.

*** Design for Concurrency
- Programming with threads imposes some design constraints. Concurrency forces you to think through things a bit more carefully

*** Cleaner Interfaces
- Thinking about concurrency and time-ordered dependencies can lead you to design cleaner interfaces as well. 
- Example: strtok and StringTokenizer
- TIP: *Always Design for Concurrency*

*** Deployment
- Once you've designed an architecture with an element of concurrency, it becomes easier to think about handling /many/ concurrent services: the model becomes pervasive.
- You can be flexible as to how the application is deployed: standalone, client-server, or n-tier.
- Add concurrency to a nonconcurrent application is much harder. If we design to allow for concurrency, we can more easily meet scalability or performance requirements when the time come -- and if the time never comes, we stil have the benefit of a cleaner design.

*** Related sections include
- Design by Contract
- Programming by Coincidence


** It's just a View
- Once you separate a program into modules based on responsibility, you have a new problem. 
  + At runtime, how do the objects talk to each other?
  + how do you manage the logical dependencies between them?
  + How do you synchronize changes in state in these different objects
- An event is simply a special message that says "something interesting just happened". We use events to signal changes in one object that some other object may be interested in.

*** Publish/Subscribe
*** Model-View-Controller
- TIP: *Separate Views from Models*
- By loosening the coupling between the model and the view/controller, you buy yourself a lot of flexibility at low cost.
- Case study: Java Tree View
*** Beyond GUIs
- MVC is a general-purpose programming technique. The view is an interpretation of the model. The model is more of a coordination mechanism

*** Still Coupled
- Despite the decrease in coupling we have achieved, listeners and event generators still have some knowledge of each other. In Java, for instance, they must agree on common interface definitions and calling conventions.

*** Related sections include
- Orthogonality
- Reversibility
- Decoupling and the Law of Demeter
- Blackboards
- It's All Writing

** Blackboards
- /The writing is on the wall.../
- Some key features of the blackboard approach are:
  + None of the detectives needs to know of the existence of any other detective -- they watch the board for new information and add their findings
  + The detectives may be trained in different disciplines, may have different levels of education and expertise, and may not even work in the same precinct. They share a desire to solve the case, and that's all.
  + Different detectives may come and go during the course of the process, and may work different shifts
  + There are no restrictions on what may be placed on the blackboard. It may be pictures, sentences, physical evidence and so on.

*** Blackboard Implementations
- originally invented for use in artificial intelligence applications where the problems to be solved were large and complex.
- Case study: JavaSpaces and TSpaces
- Organizing Your Blackboard
  + partition the blackboard and start to organize the data on the blackboard
  + different systems handle this partitioning in different ways
- TIP: *Use Blackboards to Coordinate Workflow*
*** Related sections include
- The Power of Plain Text
- It's Just a View

* While you are coding
- Conventional wisdom says that once a project is in the coding phase, the work is mostly mechanical, transcribing the design into executable statements. This attitude is the single biggest reason that many programs are ugly, inefficient, poorly structured, unmaintainable, and just plain wrong.
- Developers who don't actively think about their code are programming by coincidence

** Programming by Coincidence
- we should be wary of drawing false conclusions. We should avoid programming by coincidence - relying on luck and accidental successes - in favor of programming deliberately

*** How to Program by Coincidence
- *Accidents of Implementation*
- Accidents of implementation are things that happen simply because that's the way the code is currently written. You end up relying on undocumented error or boundary conditions.
- It's easy to be fooled in this line of thought: "It works now, better leave well enough alone...". Why should you take the risk of messing with something that's working
  + It may not really be working -- It might just look like it is
  + The boundary condition you rely on may be just an accident. In different circumstances, it might behave differently.
  + Undocumented behavior may change with the next release of the library.
  + Additional and unnecessary calls make your code slower
  + Additional calls also increase the risk of introducing new bugs of their own.
- For code you write that others will call, the basic principle of good modularization and of hiding implementation behind small, well-documented interfaces can all help. A well-specified contract can help eliminate misunderstandings.
- For routines you call, rely only on documented behavior. If you can't, for whatever reason, then document your assumption well

- *Accidents of Context*
- *Implicit Assumptions*
  + Coincidences can mislead at all levels -- from generating requirements through to testing. Testing is particularly fraught with false causalities and coincidental outcomes.
  + At all level people operate with many assumptions in mind -- but these assumptions are rarely documented and are often in conflict between different developers. Assumptions that aren't based on well-established facts are the bane of all projects.

- TIP: *Don't program by Coincidence*

*** how to Program Deliberately
- We want to spend less time churning out code, catch and fix errors as early in the development cycle as possible, and create fewer errors to begin with. It helps if we can program deliberately:
  + Always be aware of what you are doing. 
  + Don't code blindfolded. Attempting to build an application you don't fully understand, or to use a technology you aren't familiar with, is an invitation to be misled by coincidences.
  + Proceed from a plan, whether that plan is in your head, on the back of a cocktail napkin, or on a wall-sized printout from a CASE tool.
  + Rely only on reliable things. Don't depend on accidents or assumptions. If you can't tell the difference in particular circumstances, assume the worst. 
  + Document your assumptions. Design by Contract can help clarify your assumptions in your own mind, as well as help communicate them to others.
  + Don't just test your code, but test your assumptions as well. Don't guess: actually try it.
  + Prioritize your effort. Spend time on the important aspects; more than likely, these are the hard parts. if you don't have fundamentals or infrastructure correct, brilliant bells and whistles will be irrelevant.
  + Don't be a slave to history. Don't let existing code dictate future code. All code can be replaced if it is no longer appropriate. Even within one program, don't let what you've already done constraint what you do next

*** Related sections include
- Stone Soup and Boiled Frogs
- Debugging
- Design by Contract
- Assertive Programming
- Temporal Coupling
- Refactoring
- It's All Writing



** Algorithm Speed
- There is another kind of estimating that Pragmatic Programmers use almost daily: estimating the resources that algorithms use -- time, processor, memory, and so on. It turns out that these questions can often be answered using common sense, some analysis, and a way of writing approximations called the "big O" notation.

*** What Do We mean by Estimating Algorithms?
- We find that whenever we write anything containing loops or recursive calls, we subconsciously check the runtime and memory requirements. 

*** The O() notation
*** Common Sense Estimation
- You can estimate the order of many basic algorithms using common sense
  + Simple loops: if a simple loop runs from 1 to n, then the algorithm is likely to be O(n)
  + Nested loops: If you nest a loop inside another, then your algorithm becomes O(m x n)
  + Binary Chop: If your algorithm halves the set of things it considers each time around the loop, then it is likely to be logarithmic, O(lg(n))
  + Divide and Conquer: Algorithms that partition their input, work on the two halves independently, and then combine the result can be O(nlg(n))
  + Combinatoric: Whenever algorithms start looking at the permutations of things, their running time may get out of hand. This is because permutations involve factorials. Often heuristics are used to reduce the running time of these types of algorithms in particular problem domains.

*** Algorithm Speed in Practice
- TIP: *Estimate the Order of Your algorithms*
- There are some approaches you can take to address potential problems:
  + If you have an algorithm that is O(n^2), try to find a divide and conquer approach that will take you down to O(nlg(n))
- TIP: *Test Your Estimates*
- If it's tricky getting accurate timings, use code profilers to count the number of times the different steps in your algorithm get executed, and plot these figures against the size of the input

*** Best isn't Always Best
- Be wary of /premature optimizatioin/. It's always a good idea to make sure an algorithm really is a bottleneck before investing your precious time trying to improve it

*** Related sections included
- Estimating


** Refactoring
- /Change and decay in all around I see/ H.F.Lyte, "Abide With Me"
- As a program evolves, it will become necessary to rethink earlier decisions and rework portions of the code. This process is perfectly natural. Code needs to evolve. it's not a static thing. Unfortunately, the most common metaphor for software development is building construction. But using construction as the guiding metaphor implies:
  + An architect draws up blueprints
  + Contractor dig the foundation, build the superstructure, wire and plumb, and apply finishing touches
  + The tenants move in and live happily ever after, calling building maintenance to fix any problems
--> Software doesn't quite work that way. Software is more like /gardening/
- Rewriting, reworking, and re-architecting code is collectively known as /refactoring/

*** When should you Refactor?
- When you come across a stumbling block because the code doesn't quite fit anymore, or you notice 2 things that should really be merged, or anything else at all strikes you as being "wrong", don't hesitate to change it. 
- Any number of things may cause code to qualify for refactoring:
  + Duplication
  + Nonorthogonal design
  + Outdated knowledge: things change, requirements drift, and your knowledge of the problem increases
  + Performance

*** Real-world complications
- TIP: Refactor Early, Refactor Often
- Keep track of the things that need to be refactored. If you can't refactor something immediately, make sure that it gets placed on the schedule.

*** How Do You Refactor
- Refactoring is an activity that needs to be undertaken slowly, deliberately, and carefully. Martin Fowler offers the following simple tips on how to refactor without doing more harm than good:
  + Don't try to refactor and add functionality at the same time
  + Make sure you have good tests before you begin refactoring.

*** Related sections include
- The Cat Ate My Source Code
- Software Entropy
- Stone Soup and Boiled Frogs
- The Evils of Duplication
- Orthogonality
- Programming by Coincidence
- Code that's easy to test
- Ruthless Testing


** Code That's Easy to Test
- The Software IC is a metaphor that people like to toos around when discussing reusability and component based development. The idea is that software components should be combined just as integrated circuit chips are combined. This works only if the components you are using are known to be reliable.
- We need to build testability into the software from the beginning, and test piece thoroughly before trying to wire them together.

*** Unit Testing
- testing done on each module, in isolation, to verify its behavior. 
- a software unit test is code that exercises a module. 
- when we assemble oru "software IC's" into a complete system, we'll have confidence that the individual parts work as expected, and then we can use the same unit test facilities to test the system as a whole.
- decide what to test at the unit level using "design by contract"

*** Testing Against Contract
- think of unit testing as /testing against contract/. This will tell us 2 things:
  + whether the code meet the contract
  + whether the contract means what we think it means.
- we want to test that the module delivers the functionality it promises, over a wide range of test cases and boundary conditions.
- Suppose we have a module A that uses a LinkedList and a Sort. in order, we would test:
  + LinkedList's contract, in full
  + Sort's contract, in full
  + A's contract, which relies on the other contracts but does not directly expose them
- TIP: *Design to Test*
- When you design a module, or even a single routine, you should design both its contract and the code to test that contract.

*** Writing Unit Tests
- The Unit tests for a module shouldn't be shoved in some far-away corner
- making the test code readily accessible provides developers 2 invaluable resources:
  + examples of how to use all the functionality of your module
  + a means to build regression tests to validate any future changes to the code

*** Using Test harnesses
- Regardless of the technology you decide to use, test harnesses should include the following capabilities:
  + A standard way to specify setup and cleanup
  + A method for selecting individual tests or all available tests
  + A means of analyzing output for expected (or unexpected) results
  + A standardized form of failure reporting
*** Build a Test Window
- You'll need to test a piece of software once it has been deployed. 
  + Log files containing trace messages are one such mechanism
  + "hot-key" sequence: a particular combination of keys is pressed -> a diagnostic control window pops up with status messages
  + point a web browser to the application's HTTP port and see internal status, log entries, some sort of debug control panel

*** A Culture of Testing
- All software you write will be tested, so you might as well plan on testing it thoroughly
- Testing is more cultural than technical 
- *TIP*: Test your software, or your users will

*** Related sections include:
- The Cat Ate my source code
- Orthogonality
- Design by Contract
- Refactoring
- Ruthless Testing



** Evil Wizards
- applications are getting harder and harder to write
- all the time the applications themselves are getting more complex. Most developments now use a multitier model, possibly with some middleware layer or a transaction monitor.
- Developers are struggling to keep up --> tool makers and infrastructure vendors have come up with a magic bullet, the /wizard/
- But using a wizard designed by a guru does not automatically make Joe developer equally expert.
- *TIP*: Don't use Wizard Code you don't understand

*** Related sections include
- Orthogonality
- Code Generators

*** Challenges

* Before the Project
- At the very beginning of a project, you'll need to determine the requirements. Simply listening to users is not enough: read /The Requirements Pit/
- Conventional wisdom and constraint management are the topics of /Solving impossible Puzzles/
- When you think you've got the problems solved, you may still not feel comfortable with jumping in and starting. Is it simple procrastination, or is it something more?
- Starting too soon is one problem, but waiting too long may be even worse. In /The Specification Trap/ we'll discuss the advantages of specification by example.
- No matter how well thought out it is, and regardless of which "best practices" it includes, no method can replace /thinking/

** The Requirements Pit
/Perfection is achieved, not when there is nothing left to add, but when there is nothing left to take away.../
- Requirements rarely lie on the surface. Normally, they're buried deep beneath layers of assumptions, misconceptions, and politics.
- *TIP*: Don't Gather Requrements -- Dig for Them

*** Digging for Requirements
- Document the business policies separately from the requirement, and hyperlink the two. Policy may end up as metadata in the app.
- It's important to discover the underlying reason /why/ users do a particular thing, rather than just /the way/ they currently do. At the end of the day, your development has to solve their /business problem/, not just meet their stated requirements. Documenting the reasons behind requirements would give your team invaluable information when making daily implementation decisions.
- *TIP*: Work with a User to Think Like a User

*** Documenting Requirements
- use the "use cases" to capture the requirements.
- One way of looking at use cases is to emphasize their goal-driven nature

*** Overspecifying
- A big danger in producing a requirements document is being too specific. Good requirements documents remain abstract.
- Requirements are not architecture. Requirements are not design, nor are they the user interface. Requirements are /need/

*** Seeing Further
- *TIP*: Abstractions Live Longer than Details
- The key to managing growth of requirements is to point out each new feature's impact on the schedule to the project sponsors.

*** Maintain a Glossary
- Create and maintain a project glossary

*** Get the Word Out
- If it's on the Web, the programmers may even read it

*** Related sections include
- Stone Soup and Boiled Frogs
- Good-Enough Software
- Circles and Arrows
- It's All Writing
- Great Expectations

** Solving Impossible Puzzles
- The secret to solving the puzzle is to identify the real constraints, and find a solution therein. Some constraints are /absolute/, others are merely /preconceived notions/

*** Degrees of Freedom
- The popular buzz-phrase "thinking outside the box" encourages us to recognize constraints that might not be applicable and to ignore them. But this phrase isn't entirely accurate. If the "box" is the boundary of constraints and conditions, then the trick is to /find/ the box, which may be considerably larger than you think.
- The key to solving puzzles is both to recognize the constraints placed on you and to recognize the degrees of freedom you do have.
- You must challenge any preconceived notions and evaluate whether or not they are real, hard-and-fast constraints
- It's not whether you think inside or outside the box. The problem lies in /finding/ the box - identifying the real constraints
- *TIP*: Don't think outside the Box -- Find the Box
- When faced with an intractable problem, enumerate all the possible avenues you have before you. Don't dismiss anything, no matter how unusable or stupid it sounds. Now go through the list and explain why a certain path cannot be taken.
  + Example: the Trajon horse
- Categorize and prioritize your constraints

*** There must be an Easier Way
- Step back a pace and ask yourself these questions:
  + Is there an easier way?
  + Are you trying to solve the right problem, or have you been distracted by a peripheral technicality
  + Why is this thing a problem?
  + What is it that's making it so hard to solve?
  + Does it have to be done this way?
  + Does it have to be done at all?

** Not Until You're Ready
/He who hesitates is sometimes saved/
- Great performers share a trait: they know when to start and when to wait.
- *TIP*: Listen to Nagging Doubts -- Start When You're Ready
- Software development is still not a science. Let your instincts contribute to your performance

*** Good Judgment or Procrastination?
- How can you tell when you're simply procrastinating, rather than responsibly waiting for all the pieces to fall into place?
- A technique that has worked for us in these circumstances is to start prototyping. Choose an area that you find difficult and begin producing some kind of proof of concept
- One of two things will happen:
  + you may feel you're wasting your time. This boredom is probably a good indication that your initial reluctance was just a desire to put off the commitment to start. Give up the prototype and hack into the real development
  + you suddenly realize that some basic premise was wrong. You'll feel comfortable abandoning the prototype and launching into the project proper.

** The Specification Trap
- Program specification is the process of taking a requirement and reducing it down to the point where a programmer's skill can take over. It is an act of communication, explaining and clarifying the world in such a way as to remove major ambiguities
- Writing a specification is quite a responsibility
- The problem is that many designers find it difficult to stop. They feel that unless every detail is pinned down in excruciating detail they haven't earned their daily dollar. It's a mistake:
  + It's naive to assume that a specification will ever capture every detail and nuance of a system or its requirement.
  + there is a problem with the expressive power of language itself.

- *TIP*: Some things are better done than described
- A design that leaves the coder no room for interpretation robs the programming effort of any skill and art
- As a Pragmatic Programmer, you should tend to view requirements gathering, design, and implementation as different facets of the same process - the delivery of a quality system.

*** Related sections include
- Tracer Bullets
  

** Circles and Arrows
- We like formal techniques and methods. But we believe that blindly adopting any technique without putting it into the context of your development practices and capabilities is a recipe of disappointment
- *TIP*: Don't be a Slave to Formal Methods
- Formal methods have some serious shortcomings:
  + Formal methods capture requirements using a combination of diagrams and some supporting words. We prefer to show the user a prototype and let them play with it.
  + Formal methods seem to encourage specialization. 
  + 

*** Do Methods Pay Off?
- Never underestimate the cost of adopting new tools and methods. Be prepared to treat the first projects using these techniques as a learning experience.

*** Should we use formal methods
- Absolutely! But always remember that formal development methods are just one more tool in your toolbox.
- *TIP*: Expensive Too Do Not Produce Better Designs

*** Related sections include:
- The Requirements Pit

* Pragmatic Projects
** Pragmatic Teams
- how pragmatic techniques can be applied to teams as a whole
*** No Broken Windows
- Teams as a whole should not tolerate broken windows - those small imperfections that no one fixes. 
- Some team methodologies have a quality officer - someone to whom the team delegates the responsibility for the quality of the deliverable. This is clearly ridiculous: quality can come only from individual contributions of /all/ team members.

*** Boiled Frogs
- Make sure everyone actively monitors the environment for changes. May be appoint a chief water tester.

*** Communicate
- Great project teams have a distinct personality. People look forward to meetings with them because they know that they'll see a well-prepared performance that makes everyone feel good.

*** Don't Repeat Yourself
*** Orthogonality
- *TIP*: organize Around Functionality, Not Job Functions
- We favor splitting teams functionally. Divide your people into small teams, each responsible for a particular functional aspect of the final system.

*** Automation
- A great way to ensure both consistency and accuracy is to automate everything the team does.
- Automation is an essential component of every project team. 

*** Knowing When to Stop Adding Paint
- Remember that teams are made up of individuals. Give each member the ability to shine in his or her own way. Give them just enough structure to support them and to ensure that the project delivers against its requirements.

*** Related sections include
- Software Entropy
- Stone Soup and Boiled Frogs
- Good-Enough Software
- Communicate
- The Evils of Duplication
- Orthogonality
- Design by Contract
- Decoupling and the Law of Demeter
- Ubiquitous Automation

** Ubiquitous Automation
- Civilization advances by extending the number of important operations we can perform without thinking - Alfred North Whitehead

*** All on Automatic
- *TIP*: Don't Use manual Procedures
- Use /cron/ for automatic tasks

*** Compiling the Project

** Ruthless Testing
- Pragmatic Programmers are different. We are driven to find our bugs now, so we don't have to endure the shame of others finding our bugs later.
- *TIP*: test early, test often. Test automatically.
  Coding Ain't Done 'Til All the Tests Run
- We need to look at three main aspects of project-wide testing: what to test, how to test and when to test

*** What to Test
- There are several major types of software testing that you need to perform
  + Unit testing
  + integration testing
  + validation and verification
  + resource exhaustion, errors, and recovery
  + performance testing
  + usability testing

**** Unit Testing
- A /unit test/ is code that exercises a module. 

**** Integration Testing
- /Integration testing/ shows that the major subsystems that make up the project work and play well with each other.

**** Validation and Verification
- As soon as you have an executable user interace or prototype, you need to answer an all important question: the users told you what they wanted, but is it what they need?
- Does it meet the functional requirements of the system? This too need to be tested. A bug-free system that answers the wrong question isn't very useful.

**** Resource Exhaustion, Errors, and Recovery
- Now that you have a pretty good idea that the system will behave correctly under ideal conditions, you need to discover how it will behave under /real-world/ conditions.
- In real world, you programs don't have limitless resources:
  + Memory
  + Disk space
  + CPU bandwidth
  + Wall-clock time
  + Disk bandwidth
  + Network bandwidth
  + Color palette
  + Video resolution

**** Performance Testing
- For some applications, you may need specialized testing hardware or software to stimulate the load realistically

**** Usability Testing
- Usability testing is different from the types of testing dicussed so far. It is performed with real users, under real environmental conditions.
- Failure to meet usability criteria is just as big a bug as dividing by zero

*** How to test
- We've looked at /what/ to test. Now we'll turn out attention to /how/ to test, including:
  + Regression testing
  + Test data
  + Exercising GUI systems
  + Testing the tests
  + Testing thoroughly

** It's all writing
/The palest ink is bettern than the best memory/
- Pragmatic Programmers embrace documentation as an integral part of the overall development process
- *TIP*: Treat English as Just Another Programming Language
- 2 kinds of documentation produced for a project: internal and external
  + internal: source code comments, design and test documents.
  + external: anything shipped or published

*** Comments in Code
- Code should have comments, but too many comments can be just as bad as few
- Comments should discuss /why/ something is done, its purpose and its goal. Comment how code is done is a violation of the DRY principle.
- Comments: engineering trade-offs, why decisions were made, what other alternatives were discarded
  + simple module-level header comment
  + comments for significant data, type declarations
*** Executable Documents
*** Technical Writers
*** Print it or Weave IT
*** Markup Languages
- For large-scale documentation projects, we recommend looking at some of the modern schemes for making up documentation
- Documentation and code are different views of the same underlying model, but the view is /all/ that should be different. Don't let documentation become a second-class citizen banished from the main project workflow. Treat documentation with the same care you treat code, and the users will sing your praises.

*** Related sections include
- The Evils of duplication
- Orthogonality
- The power of Plain text
- Source Code Control
- It's Just a View
- Programming by Coincidence
- The requirements pit

** Great Expectations
- *TIP*: Gently Exceed your users' Expectations

*** Communicating Expectations
- work with users so that their understanding of what you'll be delivering is accurate. 

*** The Extra Mile
*** Related sections include:
- Good-enough software
- Tracer Bullets
- Prototypes and post-it note
- The requirements pit

** Pride and Prejudice

